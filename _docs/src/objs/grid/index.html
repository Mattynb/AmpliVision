<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>AmpliVision.src.objs.grid API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AmpliVision.src.objs.grid</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="AmpliVision.src.objs.grid.Square" href="Square.html">AmpliVision.src.objs.grid.Square</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="AmpliVision.src.objs.grid.grid" href="grid.html">AmpliVision.src.objs.grid.grid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AmpliVision.src.objs.grid.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>img:Â numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid:
    def __init__(self, img: np.ndarray):
        # scanned image
        self.img = img.copy()

        # setup ratios used in the grid
        # such as the plus minus, etc.
        self.setup_ratios()

        # saving blocks here and in grid creates 2 sources of truth.
        # This list should keep index or something.
        self.blocks = []

        # represents the grid in the image as a 2D array of squares. Initialized as 2D array of None to represent empty.
        self.grid = [
            [None for _ in range(self.MAX_INDEX + 1)]
            for _ in range(self.MAX_INDEX + 1)
        ]

        self.create_grid()

    ## Setup functions ##
    def setup_ratios(self):
        &#34;&#34;&#34;
        ### Setup rations
        Function that sets up the ratios used in the grid.
        &#34;&#34;&#34;
        # max x and y coordinates of the image
        self.MAX_XY = self.img.shape[0]  # assumes image is square

        # ratios measured experimentally as a percentage of the grid
        # size of pin diameter/grid size
        self.PIN_RATIO = int(self.MAX_XY * 0.012)
        # size of edge/grid size. Edge is the &#34;lines&#34; around squares
        self.EDGE_RATIO = int(self.MAX_XY * 0.01)
        # squares are the places where you can insert the ampli blocks
        self.SQUARE_RATIO = int(self.MAX_XY * 0.089)
        # an arbitrary general tolerance
        self.PLUS_MINUS = int(self.MAX_XY * 0.005)
        self.SQUARE_LENGTH = self.SQUARE_RATIO + self.EDGE_RATIO
        self.MAX_INDEX = 9  # assumes grid is square 10x10

    def create_grid(self):
        &#34;&#34;&#34; 
        ### Create grid
        Function that creates the grid of squares in the image.
        &#34;&#34;&#34;
        # These are the stop values for the for loops.
        STOP_XY = self.MAX_XY - self.EDGE_RATIO
        STEP = self.SQUARE_LENGTH

        # iterate through the grid by moving in steps of SQUARE_LENGTH
        # until the max x and y values are reached.
        # x and y are the top left points of the squares
        # x_index and y_index are the index of the square in the grid
        for y, x in itertools.product(range(0, STOP_XY, STEP), range(0, STOP_XY, STEP)):

            # get the corresponding index of the square in the grid
            # flipped coordinates to make it (row, column)
            y_index, x_index = Utils.xy_to_index(self, x, y)

            # coordinates of the top left and bottom right points of the square
            top_left = (
                x + (self.EDGE_RATIO),
                y + (self.EDGE_RATIO)
            )
            bottom_right = (
                x + self.SQUARE_RATIO + (self.EDGE_RATIO),
                y + self.SQUARE_RATIO + (self.EDGE_RATIO)
            )

            # create a square object sq
            sq = Square(
                top_left,
                bottom_right,
                (x_index, y_index),
                self.PIN_RATIO,
                self.PLUS_MINUS,
                self.img
            )

            # add the square to the grid list
            self.grid[x_index][y_index] = sq

    ### Find functions ###

    def find_pins(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        ### Find potential pins
        ---------------
        Function that finds the pins and adds them to their bounding squares.
        The pins are found by finding the square structures in the image.

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image
        &#34;&#34;&#34;

        # Square structures are 4 points (in this case pins),
        # arranged in the shape of a square
        square_structures, pin_list = self.get_square_structures(contours)

        # adds the 4 potential pins structured as a square shape to the
        # square in the grid where the middle of the structure is located
        for square_structure, pins in zip(square_structures, pin_list):

            # get the middle of the structure
            center = find_center_of_points(square_structure)

            # get the index of sq based on the center of the structure
            # flipped coordinates to make it (row, column)
            y_index, x_index = Utils.xy_to_index(self, center[0], center[1])

            # add pins to the appropriate square in the grid
            for pin in pins:
                self.grid[x_index][y_index].add_pin(pin)

    def find_blocks(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        ### Find blocks
        ---------------
        Function that determines which squares are blocks in the grid.
        It does this by finding the potential pins (p_pins) 
        then checking if the pin is in the corners of the square and adding it to the square if it is.

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image

        #### Returns:
        None
        &#34;&#34;&#34;

        # finds the potential pins (p_pins)
        # and adds them to their bounding squares.
        self.find_pins(contours)

        # checks if the potential pins are in one of the corners of square.
        # adds potential pin as a pin to the square if it is.
        self.process_pins()

        # checks if the square has x or more pins
        # if it does, it is considered a block.
        self.add_blocks()

    ## Helper functions ##
    def process_pins(self):
        &#34;&#34;&#34;
        checks if the potential pins are in one of the corners of square.
        Adds potential pin as a pin to the square if it is.
        &#34;&#34;&#34;
        for sq in itertools.chain(*self.grid):
            if len(sq.get_p_pins()) &lt; 4:
                continue

            for p_pin in sq.get_p_pins():
                x, y, w, h = cv.boundingRect(p_pin)

                # checks if top left or bottom right point of pin
                # is inside corner of square within error range
                if sq.is_in_corners_skewed(x, y, w, h):
                    sq.add_pin(p_pin)

    ### Get functions ###

    def get_blocks(self):
        return self.blocks

    def get_contour_centers(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        Function that finds the center point of each contour

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image

        #### Returns:
        * center_to_contour_index: dictionary with center points as keys and their corresponding contour indices as values
        &#34;&#34;&#34;
        center_to_contour_index = {}
        for i, contour in enumerate(contours):
            center = find_center_of_contour(contour)
            if center is not None:
                center_to_contour_index[center] = i

        # save the indexes bounding the centers of the
        # contours in a list and remove None values
        centers = list(center_to_contour_index.keys())
        centers = [x for x in centers if x != None]

        return center_to_contour_index, centers

    def get_square_structures(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        ### Square structures
        ---------------
        Function that finds the square structures in the image.  
        A square structure is defined as 4 points (in this case potential pins) arranged in the shape of a square.

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image

        #### Returns:
        * square_structures: list of square structures
        * p_pins: list of p_pins
        &#34;&#34;&#34;
        square_structures = []
        pins = []

        # find the center of each contour
        center_to_contour_index, centers = self.get_contour_centers(contours)

        # Find all combinations of four points
        combinations = list(itertools.combinations(centers, 4))

        # useful values for debuggin
        &#34;&#34;&#34;
        point0_step = math.comb(len(centers)-1, 3)
        point1_step = math.comb(len(centers)-2, 2)
        point2_step = math.comb(len(centers)-3, 1)&#34;&#34;&#34;
        # print(&#34;centers:&#34;, len(centers), &#34;combinations:&#34;, len(combinations))
        # print(&#34;point0_step:&#34;, point0_step, &#34;point1_step:&#34;, point1_step, &#34;point2_step:&#34;, point2_step)
        index = 0
        debug_flag = 0
        #step_filter = point0_step

        # iterate through the combinations of points
        for comb in combinations:
            # (previously) missing block @ 6,4 in image 6066
            &#39;&#39;&#39;if index == 1171074: #(1179520 - point1_step - (point2_step*45) - 1):
                print(&#34;special: &#34;, index)
                debug_flag = True

            else:
                debug_flag = False
            &#39;&#39;&#39;
            if is_arranged_as_square(comb, self.img, self.SQUARE_LENGTH, recursion_flag=0, debug=debug_flag):

                # Add the square to the list of
                # combinations if it is arranged as a square
                square_structures.append(list(comb))

                # Find the indices of the contours that form the square
                contour_indices = [center_to_contour_index[point]
                                   for point in comb]
                pins.append([contours[i] for i in contour_indices])

            index += 1

        return square_structures, pins

    ## Add functions ##

    def add_blocks(self):
        for sq in itertools.chain(*self.grid):
            if len(sq.get_pins()) &gt;= 4:
                sq.is_block = True
                self.blocks.append(sq)

    def add_artificial_block(self, index: tuple[int, int], img, sq_img: np.ndarray):
        &#34;&#34;&#34;
        ### Add artificial block
        ---------------
        Function that adds an artificial block to the grid.

        #### Args:
        * index: index of the square in the grid
        * sq_img: image of the square
        &#34;&#34;&#34;

        # get the square in the grid
        i, j = index
        sq = self.grid[i][j]

        # No need to worry about all the square parameters,
        # After the colage, we can pass it through phase 1 again
        # sq.is_block = True, sq.block_type = ...
        return self.paste_block(img, sq_img, sq.tl, sq.br)

    ### Draw functions ###

    def paste_test_area(self, block):
        &#34;&#34;&#34; replaces the pixels at the block&#39;s location with the block&#39;s test area image &#34;&#34;&#34;
        
        
        # get the top left and bottom right points of the block
        tl, br = block.tl, block.br

        # get the images
        img = self.img
        test_area_img = block.test_area_img

        # pixel coordinates
        corners = block.calculate_corners_pinbased()
        y_min = corners[0][1][1]
        y_max = corners[2][0][1]
        x_min = corners[0][1][0]
        x_max = corners[2][0][0]

        # paste the image of the block&#39;s test area on the grid        
        img[y_min:y_max, x_min:x_max] = test_area_img

        self.img = img

    def paste_block(self, img, sq_img, tl, br):
        &#34; pastes the image of the block with transparent bkg on the grid &#34;

        # paste the image of the square on the grid
        # at the top left and bottom right points of the square
        # tl and br are the top left and bottom right points of the square
        center_pt = self.calculate_center(tl, br)
        # sq_img = cv.resize(sq_img, sq_size)

        img = self.add_transparent_image(img, sq_img, center_pt)

        return img

    def add_transparent_image(self, background, foreground, center_pt):
        &#34;Source: https://stackoverflow.com/questions/40895785/using-opencv-to-overlay-transparent-image-onto-another-image&#34;

        bg_h, bg_w, bg_channels = background.shape
        fg_h, fg_w, fg_channels = foreground.shape

        assert bg_channels == 3, f&#34;background image should have exactly 3 channels (RGB). found:{bg_channels}&#34;
        assert fg_channels == 4, f&#34;foreground image should have exactly 4 channels (RGBA). found:{fg_channels}&#34;

        # center the foreground image on the background image according to the center point
        x_offset = center_pt[0] - fg_w // 2
        y_offset = center_pt[1] - fg_h // 2

        w = min(fg_w, bg_w, fg_w + x_offset, bg_w - x_offset)
        h = min(fg_h, bg_h, fg_h + y_offset, bg_h - y_offset)

        if w &lt; 1 or h &lt; 1:
            return

        # clip foreground and background images to the overlapping regions
        bg_x = max(0, x_offset)
        bg_y = max(0, y_offset)
        fg_x = max(0, x_offset * -1)
        fg_y = max(0, y_offset * -1)
        foreground = foreground[fg_y:fg_y + h, fg_x:fg_x + w]
        background_subsection = background[bg_y:bg_y + h, bg_x:bg_x + w]

        # separate alpha and color channels from the foreground image
        foreground_colors = foreground[:, :, :3]
        alpha_channel = foreground[:, :, 3] / 255  # 0-255 =&gt; 0.0-1.0

        # construct an alpha_mask that matches the image shape
        alpha_mask = np.dstack((alpha_channel, alpha_channel, alpha_channel))

        # combine the background with the overlay image weighted by alpha
        composite = background_subsection * \
            (1 - alpha_mask) + foreground_colors * alpha_mask

        # overwrite the section of the background image that has been updated
        background[bg_y:bg_y + h, bg_x:bg_x + w] = composite

        return background

    def draw_gridLines(self, img: np.ndarray):
        &#34;&#34;&#34;
        ### draws grid lines
        ---------------
        Function that draws the grid lines on the image.
        &#34;&#34;&#34;

        # draw grid lines
        start = 0 + self.EDGE_RATIO
        stop = self.MAX_XY - self.EDGE_RATIO + self.PLUS_MINUS
        step = self.SQUARE_RATIO + self.EDGE_RATIO

        for i, j in itertools.product(range(start, stop, step), repeat=2):
            # vertical lines
            cv.line(img, (i, 0), (i, self.MAX_XY), (0, 255, 0), 2)
            cv.line(img, (i + self.SQUARE_RATIO, 0),
                    (i + self.SQUARE_RATIO, self.MAX_XY), (0, 255, 0), 2)

            # horizontal lines
            cv.line(img, (0, i), (self.MAX_XY, i), (0, 255, 0), 2)
            cv.line(img, (0, i + self.SQUARE_RATIO),
                    (self.MAX_XY, i + self.SQUARE_RATIO), (0, 255, 0), 2)

    def draw_blocks(self, image_copy: np.ndarray, show_pins=False, show_corners=False):
        &#34;&#34;&#34;
        Function that shows image with pins and corners drawn

        #### Args:
        * image_copy: copy of the original image
        * show_pins: boolean to show pins
        * show_corners: boolean to show corners
        &#34;&#34;&#34;
        for blk in self.blocks:
            blk.draw_pins(image_copy) if show_pins else None
            blk.draw_corners(image_copy) if show_corners else None
            cv.rectangle(image_copy, blk.tl, blk.br, (0, 0, 255), 3)

    def calculate_center(self, lft_top, rgt_bot):
        &#34;&#34;&#34;
        ### Calculate center
        ---------------
        Function that calculates the center of a square.

        #### Args:
        * lft_top: top left point of the square
        * rgt_bot: bottom right point of the square

        #### Returns:
        * center: center point of the square
        &#34;&#34;&#34;
        x = (lft_top[0] + rgt_bot[0]) // 2
        y = (lft_top[1] + rgt_bot[1]) // 2
        return (x, y)

    def get_square(self, index):
        &#34;&#34;&#34;
        ### Get square
        ---------------
        Function that gets the square at the given index.

        #### Args:
        * index: index of the square in the grid

        #### Returns:
        * square: square at the given index
        &#34;&#34;&#34;
        return self.grid[index[0]][index[1]]

    def set_square(self, index, square):
        &#34;&#34;&#34;
        ### Set square
        ---------------
        Function that sets the square at the given index.

        #### Args:
        * index: index of the square in the grid
        * square: square to set
        &#34;&#34;&#34;
        self.grid[index[0]][index[1]] = square</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AmpliVision.src.objs.grid.Grid.add_artificial_block"><code class="name flex">
<span>def <span class="ident">add_artificial_block</span></span>(<span>self, index:Â tuple[int,Â int], img, sq_img:Â numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="add-artificial-block">Add artificial block</h3>
<hr>
<p>Function that adds an artificial block to the grid.</p>
<h4 id="args">Args:</h4>
<ul>
<li>index: index of the square in the grid</li>
<li>sq_img: image of the square</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.add_blocks"><code class="name flex">
<span>def <span class="ident">add_blocks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.add_transparent_image"><code class="name flex">
<span>def <span class="ident">add_transparent_image</span></span>(<span>self, background, foreground, center_pt)</span>
</code></dt>
<dd>
<div class="desc"><p>Source: <a href="https://stackoverflow.com/questions/40895785/using-opencv-to-overlay-transparent-image-onto-another-image">https://stackoverflow.com/questions/40895785/using-opencv-to-overlay-transparent-image-onto-another-image</a></p></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.calculate_center"><code class="name flex">
<span>def <span class="ident">calculate_center</span></span>(<span>self, lft_top, rgt_bot)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="calculate-center">Calculate center</h3>
<hr>
<p>Function that calculates the center of a square.</p>
<h4 id="args">Args:</h4>
<ul>
<li>lft_top: top left point of the square</li>
<li>rgt_bot: bottom right point of the square</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>center: center point of the square</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.create_grid"><code class="name flex">
<span>def <span class="ident">create_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="create-grid">Create grid</h3>
<p>Function that creates the grid of squares in the image.</p></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.draw_blocks"><code class="name flex">
<span>def <span class="ident">draw_blocks</span></span>(<span>self, image_copy:Â numpy.ndarray, show_pins=False, show_corners=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that shows image with pins and corners drawn</p>
<h4 id="args">Args:</h4>
<ul>
<li>image_copy: copy of the original image</li>
<li>show_pins: boolean to show pins</li>
<li>show_corners: boolean to show corners</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.draw_gridLines"><code class="name flex">
<span>def <span class="ident">draw_gridLines</span></span>(<span>self, img:Â numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="draws-grid-lines">draws grid lines</h3>
<hr>
<p>Function that draws the grid lines on the image.</p></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.find_blocks"><code class="name flex">
<span>def <span class="ident">find_blocks</span></span>(<span>self, contours:Â list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="find-blocks">Find blocks</h3>
<hr>
<p>Function that determines which squares are blocks in the grid.
It does this by finding the potential pins (p_pins)
then checking if the pin is in the corners of the square and adding it to the square if it is.</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul>
<h4 id="returns">Returns:</h4>
<p>None</p></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.find_pins"><code class="name flex">
<span>def <span class="ident">find_pins</span></span>(<span>self, contours:Â list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="find-potential-pins">Find potential pins</h3>
<hr>
<p>Function that finds the pins and adds them to their bounding squares.
The pins are found by finding the square structures in the image.</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.get_blocks"><code class="name flex">
<span>def <span class="ident">get_blocks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.get_contour_centers"><code class="name flex">
<span>def <span class="ident">get_contour_centers</span></span>(<span>self, contours:Â list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Function that finds the center point of each contour</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>center_to_contour_index: dictionary with center points as keys and their corresponding contour indices as values</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.get_square"><code class="name flex">
<span>def <span class="ident">get_square</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="get-square">Get square</h3>
<hr>
<p>Function that gets the square at the given index.</p>
<h4 id="args">Args:</h4>
<ul>
<li>index: index of the square in the grid</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>square: square at the given index</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.get_square_structures"><code class="name flex">
<span>def <span class="ident">get_square_structures</span></span>(<span>self, contours:Â list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="square-structures">Square structures</h3>
<hr>
<p>Function that finds the square structures in the image.<br>
A square structure is defined as 4 points (in this case potential pins) arranged in the shape of a square.</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>square_structures: list of square structures</li>
<li>p_pins: list of p_pins</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.paste_block"><code class="name flex">
<span>def <span class="ident">paste_block</span></span>(<span>self, img, sq_img, tl, br)</span>
</code></dt>
<dd>
<div class="desc"><p>pastes the image of the block with transparent bkg on the grid</p></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.paste_test_area"><code class="name flex">
<span>def <span class="ident">paste_test_area</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<div class="desc"><p>replaces the pixels at the block's location with the block's test area image</p></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.process_pins"><code class="name flex">
<span>def <span class="ident">process_pins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>checks if the potential pins are in one of the corners of square.
Adds potential pin as a pin to the square if it is.</p></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.set_square"><code class="name flex">
<span>def <span class="ident">set_square</span></span>(<span>self, index, square)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="set-square">Set square</h3>
<hr>
<p>Function that sets the square at the given index.</p>
<h4 id="args">Args:</h4>
<ul>
<li>index: index of the square in the grid</li>
<li>square: square to set</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.grid.Grid.setup_ratios"><code class="name flex">
<span>def <span class="ident">setup_ratios</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="setup-rations">Setup rations</h3>
<p>Function that sets up the ratios used in the grid.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AmpliVision.src.objs" href="../index.html">AmpliVision.src.objs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="AmpliVision.src.objs.grid.Square" href="Square.html">AmpliVision.src.objs.grid.Square</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.grid" href="grid.html">AmpliVision.src.objs.grid.grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AmpliVision.src.objs.grid.Grid" href="#AmpliVision.src.objs.grid.Grid">Grid</a></code></h4>
<ul class="">
<li><code><a title="AmpliVision.src.objs.grid.Grid.add_artificial_block" href="#AmpliVision.src.objs.grid.Grid.add_artificial_block">add_artificial_block</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.add_blocks" href="#AmpliVision.src.objs.grid.Grid.add_blocks">add_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.add_transparent_image" href="#AmpliVision.src.objs.grid.Grid.add_transparent_image">add_transparent_image</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.calculate_center" href="#AmpliVision.src.objs.grid.Grid.calculate_center">calculate_center</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.create_grid" href="#AmpliVision.src.objs.grid.Grid.create_grid">create_grid</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.draw_blocks" href="#AmpliVision.src.objs.grid.Grid.draw_blocks">draw_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.draw_gridLines" href="#AmpliVision.src.objs.grid.Grid.draw_gridLines">draw_gridLines</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.find_blocks" href="#AmpliVision.src.objs.grid.Grid.find_blocks">find_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.find_pins" href="#AmpliVision.src.objs.grid.Grid.find_pins">find_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.get_blocks" href="#AmpliVision.src.objs.grid.Grid.get_blocks">get_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.get_contour_centers" href="#AmpliVision.src.objs.grid.Grid.get_contour_centers">get_contour_centers</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.get_square" href="#AmpliVision.src.objs.grid.Grid.get_square">get_square</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.get_square_structures" href="#AmpliVision.src.objs.grid.Grid.get_square_structures">get_square_structures</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.paste_block" href="#AmpliVision.src.objs.grid.Grid.paste_block">paste_block</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.paste_test_area" href="#AmpliVision.src.objs.grid.Grid.paste_test_area">paste_test_area</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.process_pins" href="#AmpliVision.src.objs.grid.Grid.process_pins">process_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.set_square" href="#AmpliVision.src.objs.grid.Grid.set_square">set_square</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid.Grid.setup_ratios" href="#AmpliVision.src.objs.grid.Grid.setup_ratios">setup_ratios</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
