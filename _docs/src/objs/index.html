<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>AmpliVision.src.objs API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AmpliVision.src.objs</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="AmpliVision.src.objs.graph" href="graph/index.html">AmpliVision.src.objs.graph</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="AmpliVision.src.objs.grid" href="grid/index.html">AmpliVision.src.objs.grid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="AmpliVision.src.objs.image" href="image/index.html">AmpliVision.src.objs.image</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="AmpliVision.src.objs.test_analyzer" href="test_analyzer/index.html">AmpliVision.src.objs.test_analyzer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="AmpliVision.src.objs.utils" href="utils/index.html">AmpliVision.src.objs.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AmpliVision.src.objs.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>img: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid:
    def __init__(self, img: np.ndarray):
        # scanned image
        self.img = img.copy()

        # setup ratios used in the grid
        # such as the plus minus, etc.
        self.setup_ratios()

        # saving blocks here and in grid creates 2 sources of truth.
        # This list should keep index or something.
        self.blocks = []

        # represents the grid in the image as a 2D array of squares. Initialized as 2D array of None to represent empty.
        self.grid = [
            [None for _ in range(self.MAX_INDEX + 1)]
            for _ in range(self.MAX_INDEX + 1)
        ]

        self.create_grid()

    ## Setup functions ##
    def setup_ratios(self):
        &#34;&#34;&#34;
        ### Setup rations
        Function that sets up the ratios used in the grid.
        &#34;&#34;&#34;
        # max x and y coordinates of the image
        self.MAX_XY = self.img.shape[0]  # assumes image is square

        # ratios measured experimentally as a percentage of the grid
        # size of pin diameter/grid size
        self.PIN_RATIO = int(self.MAX_XY * 0.012)
        # size of edge/grid size. Edge is the &#34;lines&#34; around squares
        self.EDGE_RATIO = int(self.MAX_XY * 0.01)
        # squares are the places where you can insert the ampli blocks
        self.SQUARE_RATIO = int(self.MAX_XY * 0.089)
        # an arbitrary general tolerance
        self.PLUS_MINUS = int(self.MAX_XY * 0.005)
        self.SQUARE_LENGTH = self.SQUARE_RATIO + self.EDGE_RATIO
        self.MAX_INDEX = 9  # assumes grid is square 10x10

    def create_grid(self):
        &#34;&#34;&#34; 
        ### Create grid
        Function that creates the grid of squares in the image.
        &#34;&#34;&#34;
        # These are the stop values for the for loops.
        STOP_XY = self.MAX_XY - self.EDGE_RATIO
        STEP = self.SQUARE_LENGTH

        # iterate through the grid by moving in steps of SQUARE_LENGTH
        # until the max x and y values are reached.
        # x and y are the top left points of the squares
        # x_index and y_index are the index of the square in the grid
        for y, x in itertools.product(range(0, STOP_XY, STEP), range(0, STOP_XY, STEP)):

            # get the corresponding index of the square in the grid
            # flipped coordinates to make it (row, column)
            y_index, x_index = Utils.xy_to_index(self, x, y)

            # coordinates of the top left and bottom right points of the square
            top_left = (
                x + (self.EDGE_RATIO),
                y + (self.EDGE_RATIO)
            )
            bottom_right = (
                x + self.SQUARE_RATIO + (self.EDGE_RATIO),
                y + self.SQUARE_RATIO + (self.EDGE_RATIO)
            )

            # create a square object sq
            sq = Square(
                top_left,
                bottom_right,
                (x_index, y_index),
                self.PIN_RATIO,
                self.PLUS_MINUS,
                self.img
            )

            # add the square to the grid list
            self.grid[x_index][y_index] = sq

    ### Find functions ###

    def find_pins(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        ### Find potential pins
        ---------------
        Function that finds the pins and adds them to their bounding squares.
        The pins are found by finding the square structures in the image.

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image
        &#34;&#34;&#34;

        # Square structures are 4 points (in this case pins),
        # arranged in the shape of a square
        square_structures, pin_list = self.get_square_structures(contours)

        # adds the 4 potential pins structured as a square shape to the
        # square in the grid where the middle of the structure is located
        for square_structure, pins in zip(square_structures, pin_list):

            # get the middle of the structure
            center = find_center_of_points(square_structure)

            # get the index of sq based on the center of the structure
            # flipped coordinates to make it (row, column)
            y_index, x_index = Utils.xy_to_index(self, center[0], center[1])

            # add pins to the appropriate square in the grid
            for pin in pins:
                self.grid[x_index][y_index].add_pin(pin)

    def find_blocks(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        ### Find blocks
        ---------------
        Function that determines which squares are blocks in the grid.
        It does this by finding the potential pins (p_pins) 
        then checking if the pin is in the corners of the square and adding it to the square if it is.

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image

        #### Returns:
        None
        &#34;&#34;&#34;

        # finds the potential pins (p_pins)
        # and adds them to their bounding squares.
        self.find_pins(contours)

        # checks if the potential pins are in one of the corners of square.
        # adds potential pin as a pin to the square if it is.
        self.process_pins()

        # checks if the square has x or more pins
        # if it does, it is considered a block.
        self.add_blocks()

    ## Helper functions ##
    def process_pins(self):
        &#34;&#34;&#34;
        checks if the potential pins are in one of the corners of square.
        Adds potential pin as a pin to the square if it is.
        &#34;&#34;&#34;
        for sq in itertools.chain(*self.grid):
            if len(sq.get_p_pins()) &lt; 4:
                continue

            for p_pin in sq.get_p_pins():
                x, y, w, h = cv.boundingRect(p_pin)

                # checks if top left or bottom right point of pin
                # is inside corner of square within error range
                if sq.is_in_corners_skewed(x, y, w, h):
                    sq.add_pin(p_pin)

    ### Get functions ###

    def get_blocks(self):
        return self.blocks

    def get_contour_centers(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        Function that finds the center point of each contour

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image

        #### Returns:
        * center_to_contour_index: dictionary with center points as keys and their corresponding contour indices as values
        &#34;&#34;&#34;
        center_to_contour_index = {}
        for i, contour in enumerate(contours):
            center = find_center_of_contour(contour)
            if center is not None:
                center_to_contour_index[center] = i

        # save the indexes bounding the centers of the
        # contours in a list and remove None values
        centers = list(center_to_contour_index.keys())
        centers = [x for x in centers if x != None]

        return center_to_contour_index, centers

    def get_square_structures(self, contours: list[np.ndarray]):
        &#34;&#34;&#34;
        ### Square structures
        ---------------
        Function that finds the square structures in the image.  
        A square structure is defined as 4 points (in this case potential pins) arranged in the shape of a square.

        #### Args:
        * contours: list of contours around non-grayscale (colorful) edges in image

        #### Returns:
        * square_structures: list of square structures
        * p_pins: list of p_pins
        &#34;&#34;&#34;
        square_structures = []
        pins = []

        # find the center of each contour
        center_to_contour_index, centers = self.get_contour_centers(contours)

        # Find all combinations of four points
        combinations = list(itertools.combinations(centers, 4))

        # useful values for debuggin
        &#34;&#34;&#34;
        point0_step = math.comb(len(centers)-1, 3)
        point1_step = math.comb(len(centers)-2, 2)
        point2_step = math.comb(len(centers)-3, 1)&#34;&#34;&#34;
        # print(&#34;centers:&#34;, len(centers), &#34;combinations:&#34;, len(combinations))
        # print(&#34;point0_step:&#34;, point0_step, &#34;point1_step:&#34;, point1_step, &#34;point2_step:&#34;, point2_step)
        index = 0
        debug_flag = 0
        #step_filter = point0_step

        # iterate through the combinations of points
        for comb in combinations:
            # (previously) missing block @ 6,4 in image 6066
            &#39;&#39;&#39;if index == 1171074: #(1179520 - point1_step - (point2_step*45) - 1):
                print(&#34;special: &#34;, index)
                debug_flag = True

            else:
                debug_flag = False
            &#39;&#39;&#39;
            if is_arranged_as_square(comb, self.img, self.SQUARE_LENGTH, recursion_flag=0, debug=debug_flag):

                # Add the square to the list of
                # combinations if it is arranged as a square
                square_structures.append(list(comb))

                # Find the indices of the contours that form the square
                contour_indices = [center_to_contour_index[point]
                                   for point in comb]
                pins.append([contours[i] for i in contour_indices])

            index += 1

        return square_structures, pins

    ## Add functions ##

    def add_blocks(self):
        for sq in itertools.chain(*self.grid):
            if len(sq.get_pins()) &gt;= 4:
                sq.is_block = True
                self.blocks.append(sq)

    def add_artificial_block(self, index: tuple[int, int], img, sq_img: np.ndarray):
        &#34;&#34;&#34;
        ### Add artificial block
        ---------------
        Function that adds an artificial block to the grid.

        #### Args:
        * index: index of the square in the grid
        * sq_img: image of the square
        &#34;&#34;&#34;

        # get the square in the grid
        i, j = index
        sq = self.grid[i][j]

        # No need to worry about all the square parameters,
        # After the colage, we can pass it through phase 1 again
        # sq.is_block = True, sq.block_type = ...
        return self.paste_block(img, sq_img, sq.tl, sq.br)

    ### Draw functions ###

    def paste_test_area(self, block):
        &#34;&#34;&#34; replaces the pixels at the block&#39;s location with the block&#39;s test area image &#34;&#34;&#34;
        
        
        # get the top left and bottom right points of the block
        tl, br = block.tl, block.br

        # get the images
        img = self.img
        test_area_img = block.test_area_img

        # pixel coordinates
        corners = block.calculate_corners_pinbased()
        y_min = corners[0][1][1]
        y_max = corners[2][0][1]
        x_min = corners[0][1][0]
        x_max = corners[2][0][0]

        # paste the image of the block&#39;s test area on the grid        
        img[y_min:y_max, x_min:x_max] = test_area_img

        self.img = img

    def paste_block(self, img, sq_img, tl, br):
        &#34; pastes the image of the block with transparent bkg on the grid &#34;

        # paste the image of the square on the grid
        # at the top left and bottom right points of the square
        # tl and br are the top left and bottom right points of the square
        center_pt = self.calculate_center(tl, br)
        # sq_img = cv.resize(sq_img, sq_size)

        img = self.add_transparent_image(img, sq_img, center_pt)

        return img

    def add_transparent_image(self, background, foreground, center_pt):
        &#34;Source: https://stackoverflow.com/questions/40895785/using-opencv-to-overlay-transparent-image-onto-another-image&#34;

        bg_h, bg_w, bg_channels = background.shape
        fg_h, fg_w, fg_channels = foreground.shape

        assert bg_channels == 3, f&#34;background image should have exactly 3 channels (RGB). found:{bg_channels}&#34;
        assert fg_channels == 4, f&#34;foreground image should have exactly 4 channels (RGBA). found:{fg_channels}&#34;

        # center the foreground image on the background image according to the center point
        x_offset = center_pt[0] - fg_w // 2
        y_offset = center_pt[1] - fg_h // 2

        w = min(fg_w, bg_w, fg_w + x_offset, bg_w - x_offset)
        h = min(fg_h, bg_h, fg_h + y_offset, bg_h - y_offset)

        if w &lt; 1 or h &lt; 1:
            return

        # clip foreground and background images to the overlapping regions
        bg_x = max(0, x_offset)
        bg_y = max(0, y_offset)
        fg_x = max(0, x_offset * -1)
        fg_y = max(0, y_offset * -1)
        foreground = foreground[fg_y:fg_y + h, fg_x:fg_x + w]
        background_subsection = background[bg_y:bg_y + h, bg_x:bg_x + w]

        # separate alpha and color channels from the foreground image
        foreground_colors = foreground[:, :, :3]
        alpha_channel = foreground[:, :, 3] / 255  # 0-255 =&gt; 0.0-1.0

        # construct an alpha_mask that matches the image shape
        alpha_mask = np.dstack((alpha_channel, alpha_channel, alpha_channel))

        # combine the background with the overlay image weighted by alpha
        composite = background_subsection * \
            (1 - alpha_mask) + foreground_colors * alpha_mask

        # overwrite the section of the background image that has been updated
        background[bg_y:bg_y + h, bg_x:bg_x + w] = composite

        return background

    def draw_gridLines(self, img: np.ndarray):
        &#34;&#34;&#34;
        ### draws grid lines
        ---------------
        Function that draws the grid lines on the image.
        &#34;&#34;&#34;

        # draw grid lines
        start = 0 + self.EDGE_RATIO
        stop = self.MAX_XY - self.EDGE_RATIO + self.PLUS_MINUS
        step = self.SQUARE_RATIO + self.EDGE_RATIO

        for i, j in itertools.product(range(start, stop, step), repeat=2):
            # vertical lines
            cv.line(img, (i, 0), (i, self.MAX_XY), (0, 255, 0), 2)
            cv.line(img, (i + self.SQUARE_RATIO, 0),
                    (i + self.SQUARE_RATIO, self.MAX_XY), (0, 255, 0), 2)

            # horizontal lines
            cv.line(img, (0, i), (self.MAX_XY, i), (0, 255, 0), 2)
            cv.line(img, (0, i + self.SQUARE_RATIO),
                    (self.MAX_XY, i + self.SQUARE_RATIO), (0, 255, 0), 2)

    def draw_blocks(self, image_copy: np.ndarray, show_pins=False, show_corners=False):
        &#34;&#34;&#34;
        Function that shows image with pins and corners drawn

        #### Args:
        * image_copy: copy of the original image
        * show_pins: boolean to show pins
        * show_corners: boolean to show corners
        &#34;&#34;&#34;
        for blk in self.blocks:
            blk.draw_pins(image_copy) if show_pins else None
            blk.draw_corners(image_copy) if show_corners else None
            cv.rectangle(image_copy, blk.tl, blk.br, (0, 0, 255), 3)

    def calculate_center(self, lft_top, rgt_bot):
        &#34;&#34;&#34;
        ### Calculate center
        ---------------
        Function that calculates the center of a square.

        #### Args:
        * lft_top: top left point of the square
        * rgt_bot: bottom right point of the square

        #### Returns:
        * center: center point of the square
        &#34;&#34;&#34;
        x = (lft_top[0] + rgt_bot[0]) // 2
        y = (lft_top[1] + rgt_bot[1]) // 2
        return (x, y)

    def get_square(self, index):
        &#34;&#34;&#34;
        ### Get square
        ---------------
        Function that gets the square at the given index.

        #### Args:
        * index: index of the square in the grid

        #### Returns:
        * square: square at the given index
        &#34;&#34;&#34;
        return self.grid[index[0]][index[1]]

    def set_square(self, index, square):
        &#34;&#34;&#34;
        ### Set square
        ---------------
        Function that sets the square at the given index.

        #### Args:
        * index: index of the square in the grid
        * square: square to set
        &#34;&#34;&#34;
        self.grid[index[0]][index[1]] = square</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AmpliVision.src.objs.Grid.add_artificial_block"><code class="name flex">
<span>def <span class="ident">add_artificial_block</span></span>(<span>self, index: tuple[int, int], img, sq_img: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="add-artificial-block">Add artificial block</h3>
<hr>
<p>Function that adds an artificial block to the grid.</p>
<h4 id="args">Args:</h4>
<ul>
<li>index: index of the square in the grid</li>
<li>sq_img: image of the square</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.add_blocks"><code class="name flex">
<span>def <span class="ident">add_blocks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.add_transparent_image"><code class="name flex">
<span>def <span class="ident">add_transparent_image</span></span>(<span>self, background, foreground, center_pt)</span>
</code></dt>
<dd>
<div class="desc"><p>Source: <a href="https://stackoverflow.com/questions/40895785/using-opencv-to-overlay-transparent-image-onto-another-image">https://stackoverflow.com/questions/40895785/using-opencv-to-overlay-transparent-image-onto-another-image</a></p></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.calculate_center"><code class="name flex">
<span>def <span class="ident">calculate_center</span></span>(<span>self, lft_top, rgt_bot)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="calculate-center">Calculate center</h3>
<hr>
<p>Function that calculates the center of a square.</p>
<h4 id="args">Args:</h4>
<ul>
<li>lft_top: top left point of the square</li>
<li>rgt_bot: bottom right point of the square</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>center: center point of the square</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.create_grid"><code class="name flex">
<span>def <span class="ident">create_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="create-grid">Create grid</h3>
<p>Function that creates the grid of squares in the image.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.draw_blocks"><code class="name flex">
<span>def <span class="ident">draw_blocks</span></span>(<span>self, image_copy: numpy.ndarray, show_pins=False, show_corners=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that shows image with pins and corners drawn</p>
<h4 id="args">Args:</h4>
<ul>
<li>image_copy: copy of the original image</li>
<li>show_pins: boolean to show pins</li>
<li>show_corners: boolean to show corners</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.draw_gridLines"><code class="name flex">
<span>def <span class="ident">draw_gridLines</span></span>(<span>self, img: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="draws-grid-lines">draws grid lines</h3>
<hr>
<p>Function that draws the grid lines on the image.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.find_blocks"><code class="name flex">
<span>def <span class="ident">find_blocks</span></span>(<span>self, contours: list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="find-blocks">Find blocks</h3>
<hr>
<p>Function that determines which squares are blocks in the grid.
It does this by finding the potential pins (p_pins)
then checking if the pin is in the corners of the square and adding it to the square if it is.</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul>
<h4 id="returns">Returns:</h4>
<p>None</p></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.find_pins"><code class="name flex">
<span>def <span class="ident">find_pins</span></span>(<span>self, contours: list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="find-potential-pins">Find potential pins</h3>
<hr>
<p>Function that finds the pins and adds them to their bounding squares.
The pins are found by finding the square structures in the image.</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.get_blocks"><code class="name flex">
<span>def <span class="ident">get_blocks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.get_contour_centers"><code class="name flex">
<span>def <span class="ident">get_contour_centers</span></span>(<span>self, contours: list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Function that finds the center point of each contour</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>center_to_contour_index: dictionary with center points as keys and their corresponding contour indices as values</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.get_square"><code class="name flex">
<span>def <span class="ident">get_square</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="get-square">Get square</h3>
<hr>
<p>Function that gets the square at the given index.</p>
<h4 id="args">Args:</h4>
<ul>
<li>index: index of the square in the grid</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>square: square at the given index</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.get_square_structures"><code class="name flex">
<span>def <span class="ident">get_square_structures</span></span>(<span>self, contours: list[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="square-structures">Square structures</h3>
<hr>
<p>Function that finds the square structures in the image.<br>
A square structure is defined as 4 points (in this case potential pins) arranged in the shape of a square.</p>
<h4 id="args">Args:</h4>
<ul>
<li>contours: list of contours around non-grayscale (colorful) edges in image</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li>square_structures: list of square structures</li>
<li>p_pins: list of p_pins</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.paste_block"><code class="name flex">
<span>def <span class="ident">paste_block</span></span>(<span>self, img, sq_img, tl, br)</span>
</code></dt>
<dd>
<div class="desc"><p>pastes the image of the block with transparent bkg on the grid</p></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.paste_test_area"><code class="name flex">
<span>def <span class="ident">paste_test_area</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<div class="desc"><p>replaces the pixels at the block's location with the block's test area image</p></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.process_pins"><code class="name flex">
<span>def <span class="ident">process_pins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>checks if the potential pins are in one of the corners of square.
Adds potential pin as a pin to the square if it is.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.set_square"><code class="name flex">
<span>def <span class="ident">set_square</span></span>(<span>self, index, square)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="set-square">Set square</h3>
<hr>
<p>Function that sets the square at the given index.</p>
<h4 id="args">Args:</h4>
<ul>
<li>index: index of the square in the grid</li>
<li>square: square to set</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Grid.setup_ratios"><code class="name flex">
<span>def <span class="ident">setup_ratios</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="setup-rations">Setup rations</h3>
<p>Function that sets up the ratios used in the grid.</p></div>
</dd>
</dl>
</dd>
<dt id="AmpliVision.src.objs.Square"><code class="flex name class">
<span>class <span class="ident">Square</span></span>
<span>(</span><span>tl: int, br: int, index: ast.Tuple, PIN_RATIO: int, PLUS_MINUS: int, img: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="square">Square</h3>
<hr>
<p>Class that represents a square in the grid_ds.</p>
<h4 id="args">Args:</h4>
<ul>
<li>tl: top left point of the square</li>
<li>br: bottom right point of the square</li>
<li>index: index of the square in the grid_ds</li>
</ul>
<h4 id="attributes">Attributes:</h4>
<ul>
<li>tl: top left point of the square</li>
<li>br: bottom right point of the square</li>
<li>index: index of the square in the grid_ds</li>
<li>block: boolean that indicates if the square is a block</li>
<li>pin_count: number of pins in the square</li>
</ul>
<h4 id="methods">Methods:</h4>
<ul>
<li>add_pin: adds a pin to the square</li>
<li>draw_pins: draws the pins in the square</li>
<li>draw_corners: draws the corners of the square</li>
<li>createImg: creates an image of the square, a cutout of the image around the square</li>
<li>add_corners: adds the corners of the square to the square object</li>
<li>is_in_corners: checks if a point is in the corners of the square</li>
<li>which_corner_is_contour_in: finds which corner of square a contour is in</li>
<li>get_rgb_avg_of_contour: gets the average RGB of a contour in the image</li>
<li>get_pins_rgb: gets the average RGB of the pins in the square</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Square:
    &#34;&#34;&#34;
    ### Square
    ---------------
    Class that represents a square in the grid_ds.

    #### Args:
    * tl: top left point of the square
    * br: bottom right point of the square
    * index: index of the square in the grid_ds

    #### Attributes:
    * tl: top left point of the square
    * br: bottom right point of the square
    * index: index of the square in the grid_ds
    * block: boolean that indicates if the square is a block
    * pin_count: number of pins in the square

    #### Methods:
    * add_pin: adds a pin to the square
    * draw_pins: draws the pins in the square
    * draw_corners: draws the corners of the square
    * createImg: creates an image of the square, a cutout of the image around the square
    * add_corners: adds the corners of the square to the square object
    * is_in_corners: checks if a point is in the corners of the square
    * which_corner_is_contour_in: finds which corner of square a contour is in
    * get_rgb_avg_of_contour: gets the average RGB of a contour in the image
    * get_pins_rgb: gets the average RGB of the pins in the square

    &#34;&#34;&#34;

    def __init__(self, tl: int, br: int, index: Tuple, PIN_RATIO: int, PLUS_MINUS: int, img: np.ndarray) -&gt; None:
        # potential pins
        self.p_pins = []

        # pins
        self.pins = []

        # block or not and type of block
        self.is_block = False
        self.block_type = &#39;&#39;

        # RBG values of the pins in the square (tl, tr, bl, br)
        self.rgb_sequence = []

        # coordinates and index in Grid
        self.tl = tl
        self.br = br
        self.index = index

        # image and image of the square for visualization if necessary
        self.img = img.copy()
        if img is not None:
            self.sq_img = self.createImg(img.copy())

        # corners of the square
        self.corners = []
        self.add_corners(PIN_RATIO, PLUS_MINUS)

        self.test_area_img = None

        # rotation of the block. 0 is vertical strip with bkg on bottom. 1 is horizontal strip with bkg on left side. etc.
        self.rotation = 0

        # ratios
        self.PIN_RATIO = PIN_RATIO
        self.PLUS_MINUS = PLUS_MINUS

    ## Get functions ##
    def get_index(self) -&gt; Tuple:
        &#34;&#34;&#34; Returns the index of the square &#34;&#34;&#34;
        return self.index

    def get_p_pins(self) -&gt; list[int]:
        &#34;&#34;&#34; Returns the potential pins in the square &#34;&#34;&#34;
        return self.p_pins

    def get_pins(self) -&gt; list[int]:
        &#34;&#34;&#34; Returns the pins in the square &#34;&#34;&#34;
        return self.pins

    def get_corners(self) -&gt; list[int]:
        &#34;&#34;&#34; Returns the corners of the square &#34;&#34;&#34;
        return self.corners

    def get_img(self) -&gt; np.ndarray:
        &#34;&#34;&#34; Returns the image of the square &#34;&#34;&#34;
        return self.img

    def get_sq_img(self) -&gt; np.ndarray:
        &#34;&#34;&#34; Returns the image of the square &#34;&#34;&#34;
        if self.sq_img is None:
            self.sq_img = self.createImg(self.img)
        return self.sq_img

    def get_test_area_img(self) -&gt; np.ndarray:
        &#34; Returns the image of squares test area (inner square where test strip can be)&#34;
        if self.test_area_img is None:
            self.test_area_img = self.create_test_area_img(self.get_sq_img())
        return self.test_area_img

    def get_block_type(self) -&gt; str:
        &#34;&#34;&#34; Returns the block type of the square &#34;&#34;&#34;
        if self.is_block:
            return self.block_type
        else:
            return &#34;Not a block&#34;

    def get_rgb_sequence(self) -&gt; list[int]:
        &#34;&#34;&#34; Returns the RGB sequence of the square &#34;&#34;&#34;
        return self.rgb_sequence

    def createImg(self, img: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34; Creates an image of the square, a cutout of the image around the square&#34;&#34;&#34;
        return img[(self.tl[1]-10):(self.br[1]+10), (self.tl[0]-10):(self.br[0]+10)]

    def create_test_area_img(self, sq_img: np.ndarray) -&gt; np.ndarray:
        &#34; Creates an image of the inner test spot&#34;

        sq_img = self.img
        corners = self.calculate_corners_pinbased()

        &#34;&#34;&#34;
        r = sq_img[a:b, c:d] means that the image r is a cutout of the image sq_img. 
        from the top left corner (a, c) to the bottom right corner (b, d).
        where a, b, c, d are the coordinates of the corners of the square.
        for example,
        a = corners[0][1][1] means that a is the y coordinate of the bottom right corner of the top right corner of the square.
        b = corners[2][0][1] means that b is the y coordinate of the top left corner of the bottom right corner of the square.
        c = corners[0][1][0] means that c is the x coordinate of the bottom right corner of the top right corner of the square.
        d = corners[2][0][0] means that d is the x coordinate of the top left corner of the bottom right corner of the square.
        &#34;&#34;&#34;

        return sq_img[corners[0][1][1]:corners[2][0][1], corners[0][1][0]:corners[2][0][0]]

    ## Add functions ##
    def add_pin(self, pin: np.ndarray) -&gt; None:
        &#34;&#34;&#34; Adds a pin to the square &#34;&#34;&#34;
        self.pins.append(pin)

    def add_p_pin(self, pin: np.ndarray) -&gt; None:
        &#34;&#34;&#34; Adds a potential pin to the square &#34;&#34;&#34;
        self.p_pins.append(pin)

    def add_corners(self, PIN_RATIO: int, PLUS_MINUS: int, p: int = 3, a: float = 1.8) -&gt; None:
        &#34;&#34;&#34; 
        Adds the corners of the square to the square object

        #### Args:
        * PIN_RATIO: ratio of the pin size to the square size
        * PLUS_MINUS: arbitrary tolerance value
        * p: &#34;padding&#34; value. Determines size of the corners.
        * a: skew value. Is the exponential determining how skewed the corners are.
        &#34;&#34;&#34;

        # top left and bottom right coordinates of the square
        tl_x, tl_y = self.tl
        br_x, br_y = self.br

        # Skewing the corners in relation to the center of the grid to account for perspective.
        # the further away from the center, the more skewed the corners are (exponential).

        # Avoiding division by zero
        SKEW_x, SKEW_y = self.calculate_skew(a)

        # The following four values: top_right, top_left, bottom_right, bottom_left are the corners of the square.
        # Each corner contains its top left and bottom right coordinates.
        # Coordinates are calculated using:
        # top left and bottom right coordinates of the square, arbitrary plus minus value, the padding value and the skew value.

        self.corners = self.calculate_corners(
            tl_x, tl_y, br_x, br_y, PIN_RATIO, PLUS_MINUS, p, SKEW_x, SKEW_y)

    def calculate_skew(self, a: float) -&gt; Tuple:
        &#34;&#34;&#34; 
        Calculates the skew originated from cellphone cameras

        |x-4|^a * (x-4)/|x-4|
        &#34;&#34;&#34;
        if self.index[0] != 4:
            SKEW_x = int(
                (abs(self.index[0] - 4) ** a) * ((self.index[0] - 4) / abs(self.index[0] - 4)))
        else:
            SKEW_x = 0

        # Avoiding division by zero
        if self.index[1] != 4:
            SKEW_y = int(
                (abs(self.index[1] - 4) ** a) * ((self.index[1] - 4) / abs(self.index[1] - 4)))
        else:
            SKEW_y = 0

        return SKEW_x, SKEW_y

    def calculate_corners(self, tl_x: int, tl_y: int, br_x: int, br_y: int, PIN_RATIO: int, PLUS_MINUS: int, p: int, SKEW_x: int, SKEW_y: int) -&gt; list[int]:
        &#34;&#34;&#34;
        Calculates the corners of the square using magic. The &#34;corners&#34; here refer to the space in the ampli block where the pins are located.
        &#34;&#34;&#34;
        top_right = (
            (tl_x - (p*PLUS_MINUS) + SKEW_x, tl_y - (p*PLUS_MINUS) + SKEW_y),
            (tl_x + PIN_RATIO + (p*PLUS_MINUS) + SKEW_x,
             tl_y + PIN_RATIO + (p*PLUS_MINUS) + SKEW_y)
        )

        top_left = (
            (br_x - PIN_RATIO - (p*PLUS_MINUS) +
             SKEW_x, tl_y - (p*PLUS_MINUS) + SKEW_y),
            (br_x + (p*PLUS_MINUS) + SKEW_x, tl_y +
             PIN_RATIO + (p*PLUS_MINUS) + SKEW_y)
        )

        bottom_right = (
            (tl_x - (p*PLUS_MINUS) + SKEW_x, br_y -
             PIN_RATIO - (p*PLUS_MINUS) + SKEW_y),
            (tl_x + PIN_RATIO+(p*PLUS_MINUS) +
             SKEW_x, br_y + (p*PLUS_MINUS) + SKEW_y)
        )

        bottom_left = (
            (br_x - PIN_RATIO - (p*PLUS_MINUS) + SKEW_x,
             br_y - PIN_RATIO - (p*PLUS_MINUS) + SKEW_y),
            (br_x + (p*PLUS_MINUS) + SKEW_x, br_y + (p*PLUS_MINUS) + SKEW_y)
        )
        return [top_right, top_left, bottom_right, bottom_left]

    def calculate_corners_pinbased(self) -&gt; list[list[int]]:
        &#34;&#34;&#34;
        Calculates the corners of the square based on the pins in the square.
        To be used after the pins have been added to the square.
        list[[corner_tl, corner_br], ...] in clockwise order starting from top left.
        &#34;&#34;&#34;
        corners = []
        # pin is a list of contours
        for pin in self.pins:
            x, y, w, h = cv.boundingRect(pin)

            # add extra padding to the corners
            px, py = self.calculate_skew(0.2)
            px = int(px)
            py = int(py)

            # append top left and bottom right points of the test area
            corners.append([(x-px, y-py), (x+w+px, y+h+py)])

        return self.order_corner_points(corners)

    ## Drawing functions ##

    def draw_p_pins(self, image: np.ndarray) -&gt; None:
        &#34;&#34;&#34; Draws the potential pins in the square &#34;&#34;&#34;
        for pin in self.p_pins:
            cv.drawContours(image, pin, -1, (0, 255, 0), 3)

    def draw_pins(self, image: np.ndarray) -&gt; None:
        &#34;&#34;&#34; Draws the pins in the square &#34;&#34;&#34;
        for pin in self.pins:
            cv.drawContours(image, pin, -1, (0, 255, 0), 3)

    def draw_corners(self, img: np.ndarray) -&gt; None:
        &#34;&#34;&#34; Draws the corners of the square &#34;&#34;&#34;
        for corner in self.corners:
            cv.rectangle(img, corner[0], corner[1], (0, 0, 255), 1)

    def draw_corners_pinbased(self, img: np.ndarray) -&gt; None:
        &#34;&#34;&#34; Draws the corners of the square based on the pins in the square
        To be used after the pins have been added to the square.&#34;&#34;&#34;
        # pin is a list of contours
        for x, y in self.calculate_corners_pinbased():
            cv.rectangle(img, x, y, (0, 0, 255), 1)

    def draw_test_area(self, img: np.ndarray) -&gt; None:
        &#34;Draws the test area of the square&#34;

        corners = self.calculate_corners_pinbased()
        cv.rectangle(img, corners[0][1], corners[2][0], (0, 0, 255), 1)

    ### Boolean functions ###
    def is_in_test_bounds(self, x: int, y: int) -&gt; bool:
        &#34;checks if coordinate is within test bounds (inner square where strip is)&#34;

        pass

    def is_in_corners(self, x: int, y: int) -&gt; bool:
        &#34;&#34;&#34; 
        Checks if a point is in the corners of the square. 
        &#34;&#34;&#34;
        # corn = [&#34;top_left&#34;, &#34;top_right&#34;, &#34;bottom_left&#34;, &#34;bottom_right&#34;]

        i = 0
        for corner in self.corners:
            if x &gt;= corner[0][0] and x &lt;= corner[1][0]:
                if y &gt;= corner[0][1] and y &lt;= corner[1][1]:
                    # print(corn[i], &#34;: &#34;, round(self.get_rgb_avg_of_contour(contour)))
                    return True
            i += 1

        return False

    def is_in_corners_skewed(self, x: int, y: int, w: float, h: float) -&gt; bool:
        &#34;&#34;&#34; Checks if a point is in the corners of the square, 
        taking into consideration the skewing that happens.&#34;&#34;&#34;
        return (self.is_in_corners(x, y) or
                self.is_in_corners(x+int(w), y+int(h)) or
                self.is_in_corners(x-int(w), y-int(h)) or
                self.is_in_corners(x+int(w), y-int(h)) or
                self.is_in_corners(x-int(w), y+int(h)))

    def which_corner_is_contour_in(self, contour: np.ndarray = None, xy=None) -&gt; str:
        &#34;&#34;&#34;
        Function that finds which corner of square a contour is in.
        &#34;&#34;&#34;
        corn = [&#34;top_left&#34;, &#34;top_right&#34;, &#34;bottom_left&#34;, &#34;bottom_right&#34;]

        if xy is None:
            x, y = cv.boundingRect(contour)[:2]
        else:
            x, y = xy
            x = int(x)
            y = int(y)

        i = 0
        for corner in self.corners:
            if x &gt;= corner[0][0] and x &lt;= corner[1][0]:
                if y &gt;= corner[0][1] and y &lt;= corner[1][1]:
                    return corn[i]
            i += 1

        # might be unecessary after corner skewing
        i = 0
        for corner in self.corners:
            if x + (2*self.PLUS_MINUS) &gt;= corner[0][0] and x - (2*self.PLUS_MINUS) &lt;= corner[1][0]:
                if y + (2*self.PLUS_MINUS) &gt;= corner[0][1] and y - (2*self.PLUS_MINUS) &lt;= corner[1][1]:
                    return corn[i]
            i += 1

    def order_corner_points(self, corners: list[int]) -&gt; list[int]:
        &#34;&#34;&#34;
        Orders the corners of the square in a clockwise manner starting from the top-left corner.
        &#34;&#34;&#34;
        # top right, top left, bottom right, bottom left
        ordered_corners = [None, None, None, None]

        for xy in corners:
            mid_x = (xy[0][0] + xy[1][0]) / 2
            mid_y = (xy[0][1] + xy[1][1]) / 2
            s = self.which_corner_is_contour_in(xy=(mid_x,  mid_y))

            if s == &#34;top_left&#34;:
                ordered_corners[0] = xy
            elif s == &#34;top_right&#34;:
                ordered_corners[1] = xy
            elif s == &#34;bottom_right&#34;:
                ordered_corners[2] = xy
            elif s == &#34;bottom_left&#34;:
                ordered_corners[3] = xy

        if None in ordered_corners:
            print(&#34;\nError in ordering corners\n&#34;)
            return None

        return ordered_corners

    # set functions

    def set_rgb_sequence(self) -&gt; None:
        &#34;&#34;&#34;
        ### Set rgb sequence
        ---------------
        Function that sets the rgb sequence of the square.

        #### Returns:
        * None
        &#34;&#34;&#34;

        # get the RGB values of the pins in the square
        pins_rgb, corner_key = get_pins_rgb(self)

        # fixing the order from tr,tl,br,bl to clockwise starting from top-right. This might be the ugliest code I&#39;ve ever written. But it works!
        set_rgb_sequence_clockwise(self, pins_rgb, corner_key)

    def set_test_area_img(self, img):
        &#34; Sets the image of the test area&#34;
        self.test_area_img = img</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AmpliVision.src.objs.Square.add_corners"><code class="name flex">
<span>def <span class="ident">add_corners</span></span>(<span>self, PIN_RATIO: int, PLUS_MINUS: int, p: int = 3, a: float = 1.8) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the corners of the square to the square object</p>
<h4 id="args">Args:</h4>
<ul>
<li>PIN_RATIO: ratio of the pin size to the square size</li>
<li>PLUS_MINUS: arbitrary tolerance value</li>
<li>p: "padding" value. Determines size of the corners.</li>
<li>a: skew value. Is the exponential determining how skewed the corners are.</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Square.add_p_pin"><code class="name flex">
<span>def <span class="ident">add_p_pin</span></span>(<span>self, pin: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a potential pin to the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.add_pin"><code class="name flex">
<span>def <span class="ident">add_pin</span></span>(<span>self, pin: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a pin to the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.calculate_corners"><code class="name flex">
<span>def <span class="ident">calculate_corners</span></span>(<span>self, tl_x: int, tl_y: int, br_x: int, br_y: int, PIN_RATIO: int, PLUS_MINUS: int, p: int, SKEW_x: int, SKEW_y: int) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the corners of the square using magic. The "corners" here refer to the space in the ampli block where the pins are located.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.calculate_corners_pinbased"><code class="name flex">
<span>def <span class="ident">calculate_corners_pinbased</span></span>(<span>self) ‑> list[list[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the corners of the square based on the pins in the square.
To be used after the pins have been added to the square.
list[[corner_tl, corner_br], &hellip;] in clockwise order starting from top left.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.calculate_skew"><code class="name flex">
<span>def <span class="ident">calculate_skew</span></span>(<span>self, a: float) ‑> ast.Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the skew originated from cellphone cameras</p>
<p>|x-4|^a * (x-4)/|x-4|</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.createImg"><code class="name flex">
<span>def <span class="ident">createImg</span></span>(<span>self, img: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an image of the square, a cutout of the image around the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.create_test_area_img"><code class="name flex">
<span>def <span class="ident">create_test_area_img</span></span>(<span>self, sq_img: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an image of the inner test spot</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.draw_corners"><code class="name flex">
<span>def <span class="ident">draw_corners</span></span>(<span>self, img: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the corners of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.draw_corners_pinbased"><code class="name flex">
<span>def <span class="ident">draw_corners_pinbased</span></span>(<span>self, img: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the corners of the square based on the pins in the square
To be used after the pins have been added to the square.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.draw_p_pins"><code class="name flex">
<span>def <span class="ident">draw_p_pins</span></span>(<span>self, image: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the potential pins in the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.draw_pins"><code class="name flex">
<span>def <span class="ident">draw_pins</span></span>(<span>self, image: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the pins in the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.draw_test_area"><code class="name flex">
<span>def <span class="ident">draw_test_area</span></span>(<span>self, img: numpy.ndarray) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the test area of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_block_type"><code class="name flex">
<span>def <span class="ident">get_block_type</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the block type of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_corners"><code class="name flex">
<span>def <span class="ident">get_corners</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the corners of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_img"><code class="name flex">
<span>def <span class="ident">get_img</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the image of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_index"><code class="name flex">
<span>def <span class="ident">get_index</span></span>(<span>self) ‑> ast.Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the index of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_p_pins"><code class="name flex">
<span>def <span class="ident">get_p_pins</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the potential pins in the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_pins"><code class="name flex">
<span>def <span class="ident">get_pins</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the pins in the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_rgb_sequence"><code class="name flex">
<span>def <span class="ident">get_rgb_sequence</span></span>(<span>self) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the RGB sequence of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_sq_img"><code class="name flex">
<span>def <span class="ident">get_sq_img</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the image of the square</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.get_test_area_img"><code class="name flex">
<span>def <span class="ident">get_test_area_img</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the image of squares test area (inner square where test strip can be)</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.is_in_corners"><code class="name flex">
<span>def <span class="ident">is_in_corners</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a point is in the corners of the square.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.is_in_corners_skewed"><code class="name flex">
<span>def <span class="ident">is_in_corners_skewed</span></span>(<span>self, x: int, y: int, w: float, h: float) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a point is in the corners of the square,
taking into consideration the skewing that happens.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.is_in_test_bounds"><code class="name flex">
<span>def <span class="ident">is_in_test_bounds</span></span>(<span>self, x: int, y: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>checks if coordinate is within test bounds (inner square where strip is)</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.order_corner_points"><code class="name flex">
<span>def <span class="ident">order_corner_points</span></span>(<span>self, corners: list[int]) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Orders the corners of the square in a clockwise manner starting from the top-left corner.</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.set_rgb_sequence"><code class="name flex">
<span>def <span class="ident">set_rgb_sequence</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h3 id="set-rgb-sequence">Set rgb sequence</h3>
<hr>
<p>Function that sets the rgb sequence of the square.</p>
<h4 id="returns">Returns:</h4>
<ul>
<li>None</li>
</ul></div>
</dd>
<dt id="AmpliVision.src.objs.Square.set_test_area_img"><code class="name flex">
<span>def <span class="ident">set_test_area_img</span></span>(<span>self, img)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the image of the test area</p></div>
</dd>
<dt id="AmpliVision.src.objs.Square.which_corner_is_contour_in"><code class="name flex">
<span>def <span class="ident">which_corner_is_contour_in</span></span>(<span>self, contour: numpy.ndarray = None, xy=None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Function that finds which corner of square a contour is in.</p></div>
</dd>
</dl>
</dd>
<dt id="AmpliVision.src.objs.TestAnalyzer"><code class="flex name class">
<span>class <span class="ident">TestAnalyzer</span></span>
<span>(</span><span>block)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is responsible for getting and analyzing test results a.k.a phase B</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestAnalyzer:
    &#34;This class is responsible for getting and analyzing test results a.k.a phase B&#34;

    def __init__(self, block):

        self.block = block

        # look only at the inner test square:
        self.test_square_img = block.get_test_area_img()

        # square used in csv export
        self.grid_index = block.index
        self.block_type = block.get_block_type()

        self.strip_sections = {
            &#34;bkg&#34;: StripSection(self.test_square_img, &#39;bkg&#39;, block.rotation),
            &#34;spot1&#34;: StripSection(self.test_square_img, &#39;spot1&#39;, block.rotation),
            &#34;spot2&#34;: StripSection(self.test_square_img, &#39;spot2&#39;, block.rotation)
        }

    def analyze_test_result(self, double_thresh = False, display: bool = False):  # should I name it main?
        &#34;gets test results from a block, analyses them, and export them to csv&#34;

        # find the positive spots with hsv mask
        # need to think about cases where mask for example return one pixel.
        #   do you check for minimum contour size? do you only look for it manually? food for thought

        if display:
            print(&#34;rotation: &#34;, self.block.rotation)

        # thresholds optimized for marker data
        rgb_spots = ColorContourExtractor.process_image(
            self.test_square_img, 
            hsv_lower=[0, 40, 20],
            double_thresh=double_thresh, 
            display=display
        )
        

        if display:
            cv.waitKey(100)
            plt.close()
            cv.destroyAllWindows()

        self.add_positives_to_sections(rgb_spots, display=display)

        # find the negative spots &#34;manually&#34; through ratios
        self.add_negatives_to_sections(display=display) 

        # get background color noise so we can remove it from other sections
        self.strip_sections[&#39;bkg&#39;].set_total_avg_rgb()
        bkg_rgb_avg = self.strip_sections[&#39;bkg&#39;].total_avg_rgb

        # remove background noise from other sections
        corrected_rgbs = []
        for section in self.strip_sections.values():
            if section.strip_type != &#39;bkg&#39;:

                if display:
                    print(f&#34;{section.strip_type}AVG RGB: {section.total_avg_rgb}&#34;)
                    print(&#34;correcting: &#34;, section.strip_type)

                corrected_rgbs.append(section.subtract_bkg(bkg_rgb_avg))

        if display:
            print(&#34;\n&#34;)

        # validate results to catch any potential errors in the test
        &#34;TODO: adapt validate_results to work with the new strip configuration&#34;
        # self.validate_results()

        # export results to csv
        row = self.create_csv_row(corrected_rgbs)
        return row
    

    def add_positives_to_sections(self, rgb_spots, display: int = 0) -&gt; None:
        &#34;used to add positive result spots to appropriate strip section&#34;

        # adds each spot to its strip section
        for spot in rgb_spots:
            # display the spot
            cpy = cv.drawContours(self.test_square_img.copy(), [spot], -1, (0, 255, 0), 1)
            #plt.imshow(f&#39;TA/add_positives_to_sections&#39;, cv.resize(cpy, (400, 400)))
            

            for section in self.strip_sections.values():
                if section.bounds_contour(spot):
                    section.add_spot(self.block, spot, True, debug=display)
                    # break # only adds to one section

    def add_negatives_to_sections(self, display: int = 0) -&gt; None:
        &#34;used to find negative result spots to appropriate strip section&#34;
        for type, section in zip(self.strip_sections.keys(), self.strip_sections.values()):

            if len(section.spots) == 0:
                section.set_spots_manually(self.block, debug=display)

    def validate_results(self) -&gt; None:
        &#34;deals with test result potential positive, negative, false positive, error scenarios&#34;

        results = self.get_section_results()

        # 1 test is properly positive (bkg, test, and spot2 line rgbs are &gt; threshold)
        if results[1] &amp; results[2]:
            print(&#34;Test worked properly and result is positive&#34;)

        # 2 test is properly negative (spot2 line rgb is &gt; threshold)
        elif (not results[1]) &amp; results[2]:
            print(&#34;Test worked properly and result is negative&#34;)

        # 3 spot2 error (bkg, and maybe test line rgbs are &gt; threshold)
        else:
            print(&#34;Test may have not worked properly&#34;)

    def get_section_results(self) -&gt; list[bool]:
        &#34;returs a list of booleans representing the result (positive or negative) of each section bkg, test, spot2&#34;
        results = []  # bkg, test, spot2
        for strip in self.strip_sections.values():
            strip_result = False

            # display
            # strip.print_spots()

            for spot in strip.spots:
                if spot[&#34;positive&#34;] == True:
                    strip_result = True
                    break
            results.append(strip_result)

        print(&#34;\n&#34;)

        return results

    def create_csv_row(self, corrected_rgbs: list[list]) -&gt; str:
        &#34;&#34;&#34;
        writes the test results to csv file row in format:\n
        date, time, grid_index, block_type, bkg_r, bkg_g, bkg_b, test_r, test_g, test_b, cntrl_r, cntrl_g, cntrl_b&#34;&#34;&#34;

        # get current date and time
        now = datetime.now()

        # format date and time
        date = now.strftime(&#34;%m/%d/%Y&#34;)
        time = now.strftime(&#34;%H:%M:%S&#34;)

        # setting all rgb values to None
        bkg_r = &#34; None&#34;
        bkg_g, bkg_b = bkg_r, bkg_r
        spot1_r, spot1_g, spot1_b = bkg_r, bkg_r, bkg_r
        spot2_r, spot2_g, spot2_b = bkg_r, bkg_r, bkg_r

        # get rgb values of each section
        if self.strip_sections[&#39;bkg&#39;].total_avg_rgb != None:
            bkg_b, bkg_g, bkg_r = self.strip_sections[&#39;bkg&#39;].total_avg_rgb
            # print(&#34;bkg rgb: &#34;, bkg_r, bkg_g, bkg_b)

        if self.strip_sections[&#39;spot1&#39;].total_avg_rgb != None:
            spot1_b, spot1_g, spot1_r = self.strip_sections[&#39;spot1&#39;].total_avg_rgb
            #print(&#34;spot1 rgb: &#34;, test_r, test_g, test_b)

        if self.strip_sections[&#34;spot2&#34;].total_avg_rgb != None:
            spot2_b, spot2_g, spot2_r = self.strip_sections[&#39;spot2&#39;].total_avg_rgb

        spot1_corr_b, spot1_corr_g, spot1_corr_r = corrected_rgbs[0]
        spot2_corr_b, spot2_corr_g, spot2_corr_r = corrected_rgbs[1]

        # create data to be written to csv
        data = [
            date, time, self.grid_index, self.block_type,
            spot1_r, spot1_g, spot1_b,
            spot2_r, spot2_g, spot2_b,
            bkg_r, bkg_g, bkg_b,
            spot1_corr_r, spot1_corr_g, spot1_corr_b,
            spot2_corr_r, spot2_corr_g, spot2_corr_b
        ]

        return data

    def paint_spots(self, rgb_spot_results: dict[list]):
        &#34;&#34;&#34; colors the spots in the image accourding to the results 

        Args:
            rgb_spot_results (dict[list]): dictionary containing the rgb values of the spots in the image
            format: {r: [mean1, std1, mean2, std2], g: [mean1, std1, mean2, std2], b: [mean1, std1, mean2, std2]}
        &#34;&#34;&#34;
        from numpy import random
        import time 

        # can show improved performance if get_rgb_avg_of_contour TODO is done
        t = time.time()
        self.analyze_test_result()
        #print(f&#34;        analyze_test_result in {round(time.time() - t,2)}&#34;)

        image = self.test_square_img
        image_ = image.copy()
        for type, section in self.strip_sections.items():
            
            # dont paint bkg
            if section.strip_type == &#39;bkg&#39;:
                continue
            
            # get the correct index for result
            i = 0 if type == &#39;spot1&#39; else 2

            rgb = []
            means = []
            for c in (&#39;b&#39;, &#39;g&#39;, &#39;r&#39;):
                mean, std = rgb_spot_results[c][i:i+2]
                means.append(mean)
                
                rgb.append(int(random.normal(mean, std)))
            rgb = tuple(rgb)
            
            if means == [0,0,0]:
                continue
            
            #print(f&#34;Paiting {type} with {rgb}&#34;)
            image_ = section.paint_spot(image, rgb, display=False)
        
        self.block.set_test_area_img(image_)

        return self.block</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AmpliVision.src.objs.TestAnalyzer.add_negatives_to_sections"><code class="name flex">
<span>def <span class="ident">add_negatives_to_sections</span></span>(<span>self, display: int = 0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>used to find negative result spots to appropriate strip section</p></div>
</dd>
<dt id="AmpliVision.src.objs.TestAnalyzer.add_positives_to_sections"><code class="name flex">
<span>def <span class="ident">add_positives_to_sections</span></span>(<span>self, rgb_spots, display: int = 0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>used to add positive result spots to appropriate strip section</p></div>
</dd>
<dt id="AmpliVision.src.objs.TestAnalyzer.analyze_test_result"><code class="name flex">
<span>def <span class="ident">analyze_test_result</span></span>(<span>self, double_thresh=False, display: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>gets test results from a block, analyses them, and export them to csv</p></div>
</dd>
<dt id="AmpliVision.src.objs.TestAnalyzer.create_csv_row"><code class="name flex">
<span>def <span class="ident">create_csv_row</span></span>(<span>self, corrected_rgbs: list[list]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>writes the test results to csv file row in format:</p>
<p>date, time, grid_index, block_type, bkg_r, bkg_g, bkg_b, test_r, test_g, test_b, cntrl_r, cntrl_g, cntrl_b</p></div>
</dd>
<dt id="AmpliVision.src.objs.TestAnalyzer.get_section_results"><code class="name flex">
<span>def <span class="ident">get_section_results</span></span>(<span>self) ‑> list[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>returs a list of booleans representing the result (positive or negative) of each section bkg, test, spot2</p></div>
</dd>
<dt id="AmpliVision.src.objs.TestAnalyzer.paint_spots"><code class="name flex">
<span>def <span class="ident">paint_spots</span></span>(<span>self, rgb_spot_results: dict[list])</span>
</code></dt>
<dd>
<div class="desc"><p>colors the spots in the image accourding to the results </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rgb_spot_results</code></strong> :&ensp;<code>dict[list]</code></dt>
<dd>dictionary containing the rgb values of the spots in the image</dd>
<dt><strong><code>format</code></strong></dt>
<dd>{r: [mean1, std1, mean2, std2], g: [mean1, std1, mean2, std2], b: [mean1, std1, mean2, std2]}</dd>
</dl></div>
</dd>
<dt id="AmpliVision.src.objs.TestAnalyzer.validate_results"><code class="name flex">
<span>def <span class="ident">validate_results</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>deals with test result potential positive, negative, false positive, error scenarios</p></div>
</dd>
</dl>
</dd>
<dt id="AmpliVision.src.objs.TestGraph"><code class="flex name class">
<span>class <span class="ident">TestGraph</span></span>
<span>(</span><span>blocks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestGraph:
    def __init__(self, blocks):
        self.graph = self.build_graph(blocks)

    def build_graph(self, blocks):
        G = nx.DiGraph()

        # add nodes (block types) to graph.
        nodes = [block.block_type for block in blocks]

        # make sure duplicate names are changed. Ex [wick, wick] -&gt; [wick_1, wick_2]
        nodes = self.make_unique_names(nodes)
  
        G.add_nodes_from(nodes)
        # add edges (sequence of blocks) to graph
        positions = [block.index for block in blocks]
        
        try:
            head = nodes.index(&#39;sample_block&#39;)
        except ValueError:
            # block identification error
            return G
        
        edges = self.get_edges(nodes, positions, head)
        G.add_edges_from(edges)

        return G

    def get_edges(self, nodes: list, positions: list, head_node_index: int) -&gt; list:
        &#34;&#34;&#34;Finds the sequence of blocks. eg. sample -&gt; test 1 -&gt; test2 -&gt; wick block&#34;&#34;&#34;

        # Initialize the search
        edges = []
        head_node = nodes.pop(head_node_index)
        head_pos = positions.pop(head_node_index)

        # Start the recursive search for edges
        edges.extend(self.search_edges(head_node, head_pos, nodes, positions))

        return edges

    def search_edges(self, current_node, current_pos, remaining_nodes, remaining_positions):
        edges = []
        y, x = current_pos

        # Define potential neighbors
        neighbors = [
            (y, x + 1),
            (y, x - 1),
            (y + 1, x),
            (y - 1, x)
        ]

        for neighbor in neighbors:

            # list the grid positions. Ex: (5, 2)

            if neighbor in remaining_positions:

                # append found edge
                neighbor_index = remaining_positions.index(neighbor)
                remaining_positions.remove(neighbor)

                neighbor_node = remaining_nodes.pop(neighbor_index)
                edges.append((current_node, neighbor_node))

                # recursively search for neighboring edges and add to list
                edges.extend(
                    self.search_edges(
                        neighbor_node, neighbor, remaining_nodes, remaining_positions
                    )
                )

        return edges

    def display(self):
        G = self.graph
        pos = nx.spring_layout(G)  # Positions for all nodes
        nx.draw(G, pos, with_labels=True, node_size=2000, node_color=&#34;skyblue&#34;,
                font_size=15, font_weight=&#34;bold&#34;, arrows=True)
        plt.show()

    def make_unique_names(self, nodes):
        count = {}
        unique_names = []
        for name in nodes:
            if name in count:
                count[name] += 1
                unique_name = f&#34;{name}_{count[name]}&#34;
            else:
                count[name] = 0
                unique_name = name
            unique_names.append(unique_name)
        return unique_names

    def example_usage(self):

        # add nodes
        sequence = [1, 2, 3, 4]
        G = nx.DiGraph()
        G.add_nodes_from(sequence)

        # add edges
        edges = [(1, 2), (2, 3), (1, 4)]
        G.add_edges_from(edges)

        # Draw the graph
        pos = nx.spring_layout(G)  # Positions for all nodes
        nx.draw(G, pos, with_labels=True, node_size=2000, node_color=&#34;skyblue&#34;,
                font_size=15, font_weight=&#34;bold&#34;, arrows=True)

        # how to get graph information
        print(G.nodes)
        print(G.out_edges)

        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AmpliVision.src.objs.TestGraph.build_graph"><code class="name flex">
<span>def <span class="ident">build_graph</span></span>(<span>self, blocks)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.TestGraph.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.TestGraph.example_usage"><code class="name flex">
<span>def <span class="ident">example_usage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.TestGraph.get_edges"><code class="name flex">
<span>def <span class="ident">get_edges</span></span>(<span>self, nodes: list, positions: list, head_node_index: int) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the sequence of blocks. eg. sample -&gt; test 1 -&gt; test2 -&gt; wick block</p></div>
</dd>
<dt id="AmpliVision.src.objs.TestGraph.make_unique_names"><code class="name flex">
<span>def <span class="ident">make_unique_names</span></span>(<span>self, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="AmpliVision.src.objs.TestGraph.search_edges"><code class="name flex">
<span>def <span class="ident">search_edges</span></span>(<span>self, current_node, current_pos, remaining_nodes, remaining_positions)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AmpliVision.src" href="../index.html">AmpliVision.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="AmpliVision.src.objs.graph" href="graph/index.html">AmpliVision.src.objs.graph</a></code></li>
<li><code><a title="AmpliVision.src.objs.grid" href="grid/index.html">AmpliVision.src.objs.grid</a></code></li>
<li><code><a title="AmpliVision.src.objs.image" href="image/index.html">AmpliVision.src.objs.image</a></code></li>
<li><code><a title="AmpliVision.src.objs.test_analyzer" href="test_analyzer/index.html">AmpliVision.src.objs.test_analyzer</a></code></li>
<li><code><a title="AmpliVision.src.objs.utils" href="utils/index.html">AmpliVision.src.objs.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AmpliVision.src.objs.Grid" href="#AmpliVision.src.objs.Grid">Grid</a></code></h4>
<ul class="">
<li><code><a title="AmpliVision.src.objs.Grid.add_artificial_block" href="#AmpliVision.src.objs.Grid.add_artificial_block">add_artificial_block</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.add_blocks" href="#AmpliVision.src.objs.Grid.add_blocks">add_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.add_transparent_image" href="#AmpliVision.src.objs.Grid.add_transparent_image">add_transparent_image</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.calculate_center" href="#AmpliVision.src.objs.Grid.calculate_center">calculate_center</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.create_grid" href="#AmpliVision.src.objs.Grid.create_grid">create_grid</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.draw_blocks" href="#AmpliVision.src.objs.Grid.draw_blocks">draw_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.draw_gridLines" href="#AmpliVision.src.objs.Grid.draw_gridLines">draw_gridLines</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.find_blocks" href="#AmpliVision.src.objs.Grid.find_blocks">find_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.find_pins" href="#AmpliVision.src.objs.Grid.find_pins">find_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.get_blocks" href="#AmpliVision.src.objs.Grid.get_blocks">get_blocks</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.get_contour_centers" href="#AmpliVision.src.objs.Grid.get_contour_centers">get_contour_centers</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.get_square" href="#AmpliVision.src.objs.Grid.get_square">get_square</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.get_square_structures" href="#AmpliVision.src.objs.Grid.get_square_structures">get_square_structures</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.paste_block" href="#AmpliVision.src.objs.Grid.paste_block">paste_block</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.paste_test_area" href="#AmpliVision.src.objs.Grid.paste_test_area">paste_test_area</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.process_pins" href="#AmpliVision.src.objs.Grid.process_pins">process_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.set_square" href="#AmpliVision.src.objs.Grid.set_square">set_square</a></code></li>
<li><code><a title="AmpliVision.src.objs.Grid.setup_ratios" href="#AmpliVision.src.objs.Grid.setup_ratios">setup_ratios</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AmpliVision.src.objs.Square" href="#AmpliVision.src.objs.Square">Square</a></code></h4>
<ul class="">
<li><code><a title="AmpliVision.src.objs.Square.add_corners" href="#AmpliVision.src.objs.Square.add_corners">add_corners</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.add_p_pin" href="#AmpliVision.src.objs.Square.add_p_pin">add_p_pin</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.add_pin" href="#AmpliVision.src.objs.Square.add_pin">add_pin</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.calculate_corners" href="#AmpliVision.src.objs.Square.calculate_corners">calculate_corners</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.calculate_corners_pinbased" href="#AmpliVision.src.objs.Square.calculate_corners_pinbased">calculate_corners_pinbased</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.calculate_skew" href="#AmpliVision.src.objs.Square.calculate_skew">calculate_skew</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.createImg" href="#AmpliVision.src.objs.Square.createImg">createImg</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.create_test_area_img" href="#AmpliVision.src.objs.Square.create_test_area_img">create_test_area_img</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.draw_corners" href="#AmpliVision.src.objs.Square.draw_corners">draw_corners</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.draw_corners_pinbased" href="#AmpliVision.src.objs.Square.draw_corners_pinbased">draw_corners_pinbased</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.draw_p_pins" href="#AmpliVision.src.objs.Square.draw_p_pins">draw_p_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.draw_pins" href="#AmpliVision.src.objs.Square.draw_pins">draw_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.draw_test_area" href="#AmpliVision.src.objs.Square.draw_test_area">draw_test_area</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_block_type" href="#AmpliVision.src.objs.Square.get_block_type">get_block_type</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_corners" href="#AmpliVision.src.objs.Square.get_corners">get_corners</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_img" href="#AmpliVision.src.objs.Square.get_img">get_img</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_index" href="#AmpliVision.src.objs.Square.get_index">get_index</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_p_pins" href="#AmpliVision.src.objs.Square.get_p_pins">get_p_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_pins" href="#AmpliVision.src.objs.Square.get_pins">get_pins</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_rgb_sequence" href="#AmpliVision.src.objs.Square.get_rgb_sequence">get_rgb_sequence</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_sq_img" href="#AmpliVision.src.objs.Square.get_sq_img">get_sq_img</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.get_test_area_img" href="#AmpliVision.src.objs.Square.get_test_area_img">get_test_area_img</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.is_in_corners" href="#AmpliVision.src.objs.Square.is_in_corners">is_in_corners</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.is_in_corners_skewed" href="#AmpliVision.src.objs.Square.is_in_corners_skewed">is_in_corners_skewed</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.is_in_test_bounds" href="#AmpliVision.src.objs.Square.is_in_test_bounds">is_in_test_bounds</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.order_corner_points" href="#AmpliVision.src.objs.Square.order_corner_points">order_corner_points</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.set_rgb_sequence" href="#AmpliVision.src.objs.Square.set_rgb_sequence">set_rgb_sequence</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.set_test_area_img" href="#AmpliVision.src.objs.Square.set_test_area_img">set_test_area_img</a></code></li>
<li><code><a title="AmpliVision.src.objs.Square.which_corner_is_contour_in" href="#AmpliVision.src.objs.Square.which_corner_is_contour_in">which_corner_is_contour_in</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AmpliVision.src.objs.TestAnalyzer" href="#AmpliVision.src.objs.TestAnalyzer">TestAnalyzer</a></code></h4>
<ul class="">
<li><code><a title="AmpliVision.src.objs.TestAnalyzer.add_negatives_to_sections" href="#AmpliVision.src.objs.TestAnalyzer.add_negatives_to_sections">add_negatives_to_sections</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestAnalyzer.add_positives_to_sections" href="#AmpliVision.src.objs.TestAnalyzer.add_positives_to_sections">add_positives_to_sections</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestAnalyzer.analyze_test_result" href="#AmpliVision.src.objs.TestAnalyzer.analyze_test_result">analyze_test_result</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestAnalyzer.create_csv_row" href="#AmpliVision.src.objs.TestAnalyzer.create_csv_row">create_csv_row</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestAnalyzer.get_section_results" href="#AmpliVision.src.objs.TestAnalyzer.get_section_results">get_section_results</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestAnalyzer.paint_spots" href="#AmpliVision.src.objs.TestAnalyzer.paint_spots">paint_spots</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestAnalyzer.validate_results" href="#AmpliVision.src.objs.TestAnalyzer.validate_results">validate_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AmpliVision.src.objs.TestGraph" href="#AmpliVision.src.objs.TestGraph">TestGraph</a></code></h4>
<ul class="two-column">
<li><code><a title="AmpliVision.src.objs.TestGraph.build_graph" href="#AmpliVision.src.objs.TestGraph.build_graph">build_graph</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestGraph.display" href="#AmpliVision.src.objs.TestGraph.display">display</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestGraph.example_usage" href="#AmpliVision.src.objs.TestGraph.example_usage">example_usage</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestGraph.get_edges" href="#AmpliVision.src.objs.TestGraph.get_edges">get_edges</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestGraph.make_unique_names" href="#AmpliVision.src.objs.TestGraph.make_unique_names">make_unique_names</a></code></li>
<li><code><a title="AmpliVision.src.objs.TestGraph.search_edges" href="#AmpliVision.src.objs.TestGraph.search_edges">search_edges</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
